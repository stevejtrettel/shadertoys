#!/usr/bin/env node

/**
 * Build a specific demo for production
 * Usage: npm run build:demo <demo-name>
 * Example: npm run build:demo keyboard-test
 */

const { execSync, writeFileSync } = require('child_process');
const fs = require('fs');

const demo = process.argv[2];

if (!demo) {
  console.error('Error: Please specify a demo name');
  console.error('Usage: npm run build:demo <demo-name>');
  console.error('Example: npm run build:demo keyboard-test');
  process.exit(1);
}

console.log(`Building demo: ${demo}`);

try {
  // Generate a loader that only imports this demo's files
  // The key is using literal paths in glob patterns so Vite can tree-shake at build time
  console.log(`Generating loader for demo: ${demo}...`);
  const loaderContent = `// Auto-generated by build-demo script - DO NOT EDIT
// This file imports ONLY the files for demo: ${demo}
// The literal glob paths allow Vite to tree-shake and only bundle this demo's files

import { ShadertoyProject, ShadertoyConfig } from './types';

export const DEMO_NAME = '${demo}';

export async function loadDemoProject(): Promise<ShadertoyProject> {
  // Vite will only bundle files matching these literal paths (not other demos!)
  const glslFiles = import.meta.glob<string>('/demos/${demo}/**/*.glsl', {
    query: '?raw',
    import: 'default',
  });

  const jsonFiles = import.meta.glob<ShadertoyConfig>('/demos/${demo}/**/*.json', {
    import: 'default',
  });

  const imageFiles = import.meta.glob<string>('/demos/${demo}/**/*.{jpg,jpeg,png,gif,webp,bmp}', {
    query: '?url',
    import: 'default',
  });

  // Check if this demo has a config file
  const configPath = \`/demos/\${DEMO_NAME}/shadertoy.config.json\`;
  const hasConfig = configPath in jsonFiles;

  if (hasConfig) {
    return await loadWithConfig(jsonFiles, glslFiles, imageFiles);
  } else {
    return await loadSinglePass(glslFiles);
  }
}

async function loadSinglePass(
  glslFiles: Record<string, () => Promise<string>>
): Promise<ShadertoyProject> {
  const imagePath = \`/demos/\${DEMO_NAME}/image.glsl\`;

  if (!(imagePath in glslFiles)) {
    throw new Error(\`Demo '\${DEMO_NAME}' not found. Expected \${imagePath}\`);
  }

  const imageSource = await glslFiles[imagePath]();

  return {
    root: \`/demos/\${DEMO_NAME}\`,
    meta: {
      title: DEMO_NAME.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' '),
      author: null,
      description: null,
    },
    layout: 'centered',
    controls: false,
    commonSource: null,
    passes: {
      Image: {
        name: 'Image',
        glslSource: imageSource,
        channels: [
          { kind: 'none' },
          { kind: 'none' },
          { kind: 'none' },
          { kind: 'none' },
        ],
      },
    },
    textures: [],
  };
}

async function loadWithConfig(
  jsonFiles: Record<string, () => Promise<ShadertoyConfig>>,
  glslFiles: Record<string, () => Promise<string>>,
  imageFiles: Record<string, () => Promise<string>>
): Promise<ShadertoyProject> {
  const configPath = \`/demos/\${DEMO_NAME}/shadertoy.config.json\`;
  const config = await jsonFiles[configPath]();

  let commonSource: string | null = null;
  if (config.common) {
    const commonPath = \`/demos/\${DEMO_NAME}/\${config.common}\`;
    if (commonPath in glslFiles) {
      commonSource = await glslFiles[commonPath]();
    }
  } else {
    const defaultCommonPath = \`/demos/\${DEMO_NAME}/common.glsl\`;
    if (defaultCommonPath in glslFiles) {
      commonSource = await glslFiles[defaultCommonPath]();
    }
  }

  const texturePathsSet = new Set<string>();
  const passOrder = ['Image', 'BufferA', 'BufferB', 'BufferC', 'BufferD'] as const;

  for (const passName of passOrder) {
    const passConfig = config.passes[passName];
    if (!passConfig) continue;

    for (const channelKey of ['iChannel0', 'iChannel1', 'iChannel2', 'iChannel3'] as const) {
      const channelConfig = passConfig.channels?.[channelKey];
      if (channelConfig && 'texture' in channelConfig) {
        texturePathsSet.add(channelConfig.texture);
      }
    }
  }

  const textures: any[] = [];
  const texturePathToName = new Map<string, string>();

  for (const texturePath of texturePathsSet) {
    const fullPath = \`/demos/\${DEMO_NAME}/\${texturePath.replace(/^\\.\\//, '')}\`;

    if (!(fullPath in imageFiles)) {
      throw new Error(\`Texture not found: \${texturePath} (expected at \${fullPath})\`);
    }

    const imageUrl = await imageFiles[fullPath]();
    const textureName = texturePath.split('/').pop()!.replace(/\\.[^.]+$/, '');

    textures.push({
      name: textureName,
      source: imageUrl,
      filter: 'linear' as const,
      wrap: 'repeat' as const,
    });

    texturePathToName.set(texturePath, textureName);
  }

  const passes: any = {};

  for (const passName of passOrder) {
    const passConfig = config.passes[passName];
    if (!passConfig) continue;

    const defaultNames: Record<string, string> = {
      Image: 'image.glsl',
      BufferA: 'bufferA.glsl',
      BufferB: 'bufferB.glsl',
      BufferC: 'bufferC.glsl',
      BufferD: 'bufferD.glsl',
    };

    const sourceFile = passConfig.source || defaultNames[passName];
    const sourcePath = \`/demos/\${DEMO_NAME}/\${sourceFile}\`;

    if (!(sourcePath in glslFiles)) {
      throw new Error(\`Missing shader file: \${sourcePath}\`);
    }

    const glslSource = await glslFiles[sourcePath]();

    const channels = [
      normalizeChannel(passConfig.channels?.iChannel0, texturePathToName),
      normalizeChannel(passConfig.channels?.iChannel1, texturePathToName),
      normalizeChannel(passConfig.channels?.iChannel2, texturePathToName),
      normalizeChannel(passConfig.channels?.iChannel3, texturePathToName),
    ];

    passes[passName] = {
      name: passName,
      glslSource,
      channels,
    };
  }

  if (!passes.Image) {
    throw new Error(\`Demo '\${DEMO_NAME}' must have an Image pass\`);
  }

  const title = config.meta?.title || DEMO_NAME.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
  const author = config.meta?.author || null;
  const description = config.meta?.description || null;
  const layout = config.layout || 'centered';
  const controls = config.controls ?? false;

  return {
    root: \`/demos/\${DEMO_NAME}\`,
    meta: { title, author, description },
    layout,
    controls,
    commonSource,
    passes,
    textures,
  };
}

function normalizeChannel(channelJson: any, texturePathToName?: Map<string, string>): any {
  if (!channelJson) {
    return { kind: 'none' };
  }

  if ('buffer' in channelJson) {
    return {
      kind: 'buffer',
      buffer: channelJson.buffer,
      previous: !!channelJson.previous,
    };
  }

  if ('texture' in channelJson) {
    const textureName = texturePathToName?.get(channelJson.texture) || channelJson.texture;
    return {
      kind: 'texture2D',
      name: textureName,
    };
  }

  if ('keyboard' in channelJson) {
    return { kind: 'keyboard' };
  }

  return { kind: 'none' };
}
`;

  fs.writeFileSync('src/project/generatedLoader.ts', loaderContent);

  // TypeScript compilation
  console.log('Running TypeScript compiler...');
  execSync('tsc', { stdio: 'inherit' });

  // Vite build
  console.log(`Building with Vite...`);
  execSync(`vite build`, {
    stdio: 'inherit',
    env: { ...process.env, VITE_DEMO: demo }
  });

  console.log(`âœ“ Build complete for demo: ${demo}`);
  console.log(`Output: dist/`);
} catch (error) {
  process.exit(error.status || 1);
}
